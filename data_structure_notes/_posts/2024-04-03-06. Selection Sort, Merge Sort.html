<head>
    <title></title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./styles.css">
</head>

<body class="light-theme blue_sky" style="padding: 20px;">
    <div class="shine-editor">
        <div><br></div>
        <h2>Selection Sort</h2>
        <div>
            <pre spellcheck="false"
                data-code-language="cpp">int sort(int a[], int n)<br>{<br>    int i, j, m;<br>    for(i=0; i&lt;n; i++) {<br>        // find minimum<br>        m = i;<br>        for (j=i; j&lt;n; j++)<br>            if (a[m] &gt; a[j]) m = j;<br>        swap(a[i], a[m]);<br>    }<br>    return;<br>}</pre>
            <div><br></div>
        </div>
        <div><br></div>
        <h2>Selection Sort 증명</h2>
        <div>Sorting이 됐다는 증명을 어떻게 할 것인가?</div>
        <div>입력&nbsp;: a[0], a[1],&nbsp;…, a[n-1] &lt;- (정수)&nbsp;집합</div>
        <div>Sorting이 완료된 후 다음이 만족되어야 함</div>
        <div>
            <ul>
                <li>구분을 위해, Sorting이 끝난 후 배열에 저장된 값들을&nbsp;b[0], b[1],&nbsp;…,b[n-1]라고 부르자</li>
                <li>조건&nbsp;1: {a[0], a[1],&nbsp;…, a[n-1]} = {b[0], b[1],&nbsp;…, b[n-1]}. 두&nbsp;집합이 같음 (없어지거나 새로 생기는
                    값이 없어야 함)</li>
                <li>조건&nbsp;2: b[0] &lt; b[1] &lt;&nbsp;…&nbsp;&lt; b[n-1] (편의상 같은 값은 없다고 가정)</li>
            </ul>
        </div>
        <div>&nbsp;</div>
        <div>Proof by Invariant</div>
        <div>
            <ul>
                <li>배열 요소를 교환만 하므로,&nbsp;집합 조건을 깰 수 있는 코드는 없음</li>
                <li>Invariant: k번째 루프가 끝난 후에</li>
            </ul>
            <div>
                <ol>
                    <li>a[0] &lt; a[1] &lt;&nbsp;…&nbsp;&lt; a[k-1]</li>
                </ol>
                <div> -&gt; k=n인 경우&nbsp;a[0] &lt; a[1]&lt;&nbsp;…&nbsp;&lt; a[n-1]</div>
            </div>
        </div>
        <div>
            <ol start="2">
                <li>a[k-1] &lt; a[x] if x &gt; k-1</li>
            </ol>
        </div>
        <div>
            <ul>
                <li>이제 수학적 귀납법을 통해&nbsp;invariant를 증명하자</li>
                <ul>
                    <li>Base : k = 0</li>
                    <ul>
                        <li>1. a[0]부터&nbsp;a[-1]까지? 성립하는지 확인할 조건 자체가 없으므로(null condition) true가 된다.</li>
                        <li>2. a[-1]은 말이 안 됨.&nbsp;null condition&nbsp;이므로&nbsp;true.</li>
                    </ul>
                    <li>Step : k번째 루프가 끝났을 때&nbsp;Invariant가 성립한다면, k+1번째 루프가 끝났을 때도&nbsp;Invariant가 성립하는가?</li>
                </ul>
            </ul>
            <div>
                <ol>
                    <ul>
                        <ul>
                            <li>a[0] &lt; a[1] &lt;&nbsp;…&nbsp;&lt; a[k-1] &lt; a[k]</li>
                        </ul>
                    </ul>
                </ol>
            </div>
        </div>
        <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;a[0] &lt;&nbsp;…&nbsp;&lt; a[k-1]은&nbsp;k번째 루프의&nbsp;(1)에 의해
            성립</div>
        <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   a[k-1] &lt; a[k]&nbsp;는&nbsp;k번째 루프의&nbsp;(2)에 의해 성립.
            a[k]가&nbsp;a[x]중 무엇이였든간에&nbsp;a[k-1]&nbsp;보다 크다.</div>
        <div>
            <ul>
                <ul>
                    <ul>
                        <li>a[k] &lt; a[x] if x &gt; k</li>
                    </ul>
                </ul>
            </ul>
        </div>
        <div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;a[k],&nbsp;…, a[n-1]중 최소값을&nbsp;a[k]로 옮겼으므로 성립</div>
        <div>&nbsp;</div>
        <div>&nbsp;</div>
        <h2>Selection Sort&nbsp;재귀호출 증명</h2>
        <div>
            <pre spellcheck="false"
                data-code-language="cpp">int sort(int a[], int n)<br>{<br>    if (n&lt;=1) return;<br>    int j, m;<br>    m = 0;<br>    for(j=0; j&lt;n; j++) {<br>        if (a[m] &gt; a[j]) m = j;<br>    }<br>    swap(a[0], a[m]);<br>    sort(a+1, n-1);<br>    return;<br>}</pre>
            <div><br></div>
        </div>
        <div>조건&nbsp;1: {a[0], a[1],&nbsp;…, a[n-1]} = {b[0], b[1],&nbsp;…, b[n-1]}</div>
        <div>조건&nbsp;2: b[0] &lt; b[1] &lt;&nbsp;…&nbsp;&lt; b[n-1]</div>
        <div>&nbsp;</div>
        <div>이번에도 조건1을 깰 수 있는 코드는 없다.</div>
        <div>&nbsp;</div>
        <div>
            <ul>
                <li>Base :&nbsp;n = 1일 때,&nbsp;할 일이 없음.</li>
                <li>Step : n-1일 때&nbsp;sort()&nbsp;함수가 성공한다면&nbsp;(즉,&nbsp;재귀 호출이 끝난
                    후&nbsp;a[1]&lt;a[2]&lt;…&lt;a[n-1]&nbsp;이라면), n일 때&nbsp;sort()&nbsp;함수가 성공하는가? (함수가 끝날
                    때&nbsp;a[0]&lt;a[1]&lt;…&lt;a[n-1]이 성립하는가?)</li>
            </ul>
        </div>
        <div>
            <ul>
                <ul>
                    <li>재귀호출 전&nbsp;:&nbsp;최소값을&nbsp;a[0]에 저장하므로&nbsp;a[0]&lt;a[1], a[0]&lt;a[2],&nbsp;…,
                        a[0]&lt;a[n-1]이 성립한다.</li>
                    <li>재귀호출 이후&nbsp;:&nbsp;가정에 따라, a[1]&lt;a[2]&lt;…&lt;a[n-1]이 성립한다.&nbsp;최소값을&nbsp;a[0]에
                        저장했으므로,&nbsp;a[0]&lt;a[1]이다.&nbsp;따라서&nbsp;n일 때&nbsp;sort()함수가 성공한다.</li>
                </ul>
            </ul>
            <div><br></div>
        </div>
        <div>selection sort의 시간복잡도는 다음과 같이 계산된다.</div>
        <div><br></div>
        <div>T(n) = n + T(n-1) = n + (n-1) + T(n-2) = ... = n(n+1)/2</div>
        <div>T(n) = O(n<sup>2</sup>)</div>
        <div><br></div>
        <div><br></div>
        <h2>Recursive Merge Sort</h2>
        <div>
            <pre spellcheck="false"
                data-code-language="cpp">int sort(int a[], int n)<br>{<br>    if(n==1) return;<br><br>    int h;<br>    h = n / 2;<br><br>    int b[n];<br>    copy a[] to b[];<br><br>    sort(b, h);<br>    sort(b+h, n-h);<br>    b의 두 부분을 a에 Merge;<br><br>    return;<br>}</pre>
            <div>Merge는 정렬된 두 배열을 정렬된 한 배열로 합병하는 알고리즘이다.</div>
        </div>
        <div><br></div>
        <div><br></div>
        <h2>수학적 귀납법을 통한 Merge Sort 증명</h2>
        <div>
            <ul>
                <li>집합 조건을 깰 수 있는 코드는 없음</li>
                <li>Base : n=1 → 이미 정렬이 완료된 상태. 할 일이 없음</li>
                <li>Step : n/2일 때 sort()함수가 성공한다면</li>
                <ul>
                    <li>즉,&nbsp;재귀 호출이 끝난
                        후&nbsp;b[0]&lt;b[1]&lt;...&lt;b[h-1],&nbsp;&nbsp;b[h]&lt;b[h+1]&lt;...&lt;b[n-1] 가 성립한다면<br>
                    </li>
                    <li>Merge 알고리즘이 성공적으로 실행될 조건이 만족되었다.</li>
                    <li>따라서 sort(a, n)함수가 끝날 때&nbsp;a[0]&lt;a[1]&lt;...&lt;a[n-1]&nbsp;이 성립한다.</li>
                    <li>단, Merge 알고리즘의 정확성은 따로 증명해야 한다.</li>
                </ul>
            </ul>
        </div>
        <div><br></div>
        <div><br></div>
        <h2>Merge Sort의 시간복잡도 계산</h2>
        <div>분석을 단순화하기 위해&nbsp;n이&nbsp;2의 거듭제곱이라 가정하고,&nbsp;분할 단계에서 크기가 정확히 절반으로 나누어지는 상황을 분석해 보자.</div>
        <div>Merge과정의 시간복잡도는 Θ(n)임이 알려져 있다.&nbsp;이를 통해,&nbsp;다음 점화식을 얻을 수 있다.</div>
        <div>T(n) =&nbsp;Θ(1)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; , n=1</div>
        <div>T(n) = 2T(n/2) +&nbsp;Θ(n)&nbsp; &nbsp; , n&gt;1</div>
        <div>&nbsp;</div>
        <div>따라서</div>
        <div>T(n) = n + 2T(n/2) = n + 2(n/2 + 2T(n/4)) = n + 2(n/2 + 2(n/4 + 2T(n/8)) = ...</div>
        <div>&nbsp;&nbsp;&nbsp;&nbsp;= nlogn + 2<sup>logn</sup>T(1) = nlogn+n = O(nlogn)</div><br>
    </div>
</body>