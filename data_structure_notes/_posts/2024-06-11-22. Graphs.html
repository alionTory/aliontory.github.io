<head><title></title><meta charset="utf-8"><link rel="stylesheet" href="./styles.css"></head><body class="light-theme blue_sky" style="padding: 20px;"><div class="shine-editor"><h1>2024-06-11-22. Graphs</h1><h2>그래프의 사용</h2><div><ul><li>자동차 네비게이션</li><li>그래프형 데이터베이스</li><li>웹 크롤링에서 페이지 탐색</li><li>외부 요청에 따른 서버 상태 변화 표현</li></ul><div><br></div></div><div><br></div><h2>그래프의 정의</h2><div>그래프 G는 정점(노드)의 집합 V와 간선의 집합 E로 구성된다.</div><div>G = (V, E)</div><div><br></div><div>정점 집합 V의 원소들의 구성에 대해서는, V가 공집합이면 안된다는 것을 제외하면 제한이 없다.</div><div>간선 집합 E의 정의는 그래프의 종류가 simple graph인지 아니면 digraphs 인지에 따라 다르다.</div><div><br></div><div><ul><li>Simple Graph (Undirected Graph)</li><ul><li>E가 V의 원소로부터 만들어지는&nbsp;<span class="shine-text-red">무순서쌍</span>(원소 개수가 2개인 집합) 으로 구성된다.</li><li>ex) V = {1, 2, 3, 4, 5, 6},&nbsp; &nbsp; E = { {1, 2}, {1, 5}, {2, 5}, {3, 6} }</li><li><img width="234px" src="Files/image%20110.png"><br></li></ul><li>Digraph (Directed Graph)</li><ul><li>E가 V의 원소로부터 만들어지는&nbsp;<span class="shine-text-red">순서쌍</span>으로 구성된다.</li><li>E가 V에 대한 이항 관계(relation)라고도 할 수 있다.</li><li>ex) V = {1, 2, 3, 4, 5, 6},&nbsp; &nbsp; E = {(1, 2), (2, 2), (2, 4), (2, 5), (4, 1), (4, 5), (5, 4), (6, 3)}</li><li><img width="246px" src="Files/image%20111.png"><br></li></ul></ul><div><br></div><div><br></div><div>Simple Graph를 Digraph로 변환하여 표현하는 것이 가능하다.</div><div>Simple graph의 임의의 간선 {a, b}를 Digraph의 두 간선 (a, b)와 (b, a)로 나타내면 된다.</div><div>따라서 Digraph에서 적용 가능한 알고리즘은 Simple graph에도 적용 가능하다.</div><div><br></div><h2><br></h2><h2>Graph의 최대 간선 개수와 Complete Graph</h2></div><div>노드가 n개인 Simple graph와 Digraph는 각각 최대 몇 개의 간선을 가질 수 있고, 가능한 만들어질 수 있는 그래프가 몇 개 존재할까?</div><div><br></div><div>Simple Graph의 경우 간선은 V에서 원소 두 개를 선택한 것이므로, 간선은 최대&nbsp;<span data-formula-width-em="1.9375" data-upnote-formula="_nC_2" data-non-editable="true">_nC_2</span>, 즉 n(n-1)/2 개 존재 가능하다.</div><div>각각의 존재 가능한 간선이 실제로 존재하거나 존재하지 않거나 둘 중 하나이므로, 만들어질 수 있는 그래프의 개수는&nbsp;<span data-formula-width-em="4.1875" data-upnote-formula="2^{n(n-1)/2}" data-non-editable="true">2^{n(n-1)/2}</span>&nbsp;개이다.</div><div><br></div><div>Digraph에서는 간선 순서쌍에 왼쪽에 올 수 있는 V의 원소 개수가 n개, 오른쪽에 올 수 있는 V의 원소 개수도 n개이다. 따라서 간선은 총&nbsp;<span data-formula-width-em="1.1875" data-upnote-formula="n^2" data-non-editable="true">n^2</span>개 존재 가능하다.</div><div>Simple Graph에서 구했던 것과 마찬가지로, 각각의 간선이 실제로 존재하거나 존재하지 않거나 둘 중 하나이므로, 만들어질 수 있는 그래프의 개수는&nbsp;<span data-formula-width-em="1.5" data-upnote-formula="2^{n^2}" data-non-editable="true">2^{n^2}</span>개이다.</div><div><br></div><div>정점에 대해 존재할 수 있는 모든 간선들이 존재하는 그래프를&nbsp;<span class="shine-text-red">Complete Graph</span>라고 한다.</div><div>정점이 n개인 complete graph는 K<sub>n</sub>이라 표기한다.</div><div>K<sub>4</sub>를 그리면 다음과 같다.</div><div><img width="182px" src="Files/image%20112.png"><br></div><div><br></div><div><br></div><h2>Incident와 Adjacent</h2><div>incident와 adjacent는 둘 다 ‘인접’으로 번역되기도 한다. 하지만 그 둘의 뜻은 다르다.</div><div>incident는 정점과 간선의 관계를 나타내는 데 쓰이며, adjacent는 정점 간의 관계를 나타내는 데 쓰인다.</div><div><br></div><div><img width="244px" src="Files/image%20113.png"><br></div><div>Digraph의 정점 u, v와 간선 e = (u, v) 에 대해, e 는 u로부터 떠난다(e is&nbsp;<span class="shine-text-red">incident from</span>&nbsp;u)라고 하고, 또한 e는 v로 들어간다(e is&nbsp;<span class="shine-text-red">incident to</span>&nbsp;v) 라고 한다.</div><div>Simple Graph에서는, 간선 e = {u, v} 는 정점 u와 v에서 부속한다(e is&nbsp;<span class="shine-text-red">indident on</span>&nbsp;u, v) 라고 한다.</div><div><br></div><div>Digraph에 간선 (u, v)가 존재할 때, 정점 v가 정점 u에 인접한다(v is&nbsp;<span class="shine-text-red">adjacent</span>&nbsp;to u)고 한다.</div><div><span class="shine-text-red">v</span>를&nbsp;<span class="shine-text-red">u의 인접 정점</span>이라고도 한다.</div><div>간선 (u, v)가 존재하더라도 (v, u)가 존재하지 않는다면, 정점 u가 v에 인접하다고 할 수는 없다.</div><div>반면 Simple Graph에서 간선 {u, v}가 존재한다면, v가 u에 인접함과 동시에 v가 u에 인접한다.</div><div><br></div><div><br></div><div><h2>Degree</h2><div>simple graph에서, 정점의&nbsp;<span class="shine-text-red">Degree</span>는 해당 정점에 부속하는(incident on) 간선의 개수이다.</div><div><br></div><div>앞에서 정의한 simple graph에서는 self loop 간선(양 끝이 같은 정점에 붙은 간선)이 존재할 수 없다. 하지만 self loop를 허용하는, 즉 원소가 정점 두개가 아닌 한개뿐인 집합도 간선으로 허용하는 simple graph의 정의도 존재한다.</div><div>이 경우, self loop 간선은 Degree를 2 증가시킨다.</div><div><img width="341px" src="Files/image%20114.png"><br></div><div><br></div><div>간선 하나가 그래프의 degree 총합을 2 증가시키므로, 다음 식이 성립한다.</div><div>2*|E| = sum(deg(v<sub>i</sub>))</div><div>따라서 그래프의 degree의 총합은 짝수이며, degree가 홀수인 정점은 짝수 개 존재한다.</div><div><br></div><div>digraphs 정점의 degree는 정점으로 들어가는(incident to) 간선의 개수인&nbsp;<span class="shine-text-red">in-degree</span>와, 정점에서 떠나는(incident from) 간선의 개수인<span class="shine-text-red">&nbsp;out-degree</span>로 나뉜다.</div></div><div><br></div><div><br></div><h2>Path(경로)와 사이클</h2><div>그래프의 정점으로 구성된 순열&nbsp;<span data-formula-width-em="10.4375" data-upnote-formula="<v_0, v_1, v_2, ..., v_n>" data-non-editable="true">&lt;v_0, v_1, v_2, ..., v_n&gt;</span>&nbsp;에 대해, 간선&nbsp;<span data-formula-width-em="4.375" data-upnote-formula="(v_{i-1}, v_i)" data-non-editable="true">(v_{i-1}, v_i)</span>&nbsp;(i = 1, 2, ..., n) 가 E의 원소인 경우, 해당 순열을 “<span data-formula-width-em="1.0625" data-upnote-formula="v_0" data-non-editable="true">v_0</span>로부터&nbsp;<span data-formula-width-em="1.125" data-upnote-formula="v_n" data-non-editable="true">v_n</span>까지를 연결하는&nbsp;길이 n인&nbsp;<span class="shine-text-red">경로</span>(path)”라고 한다.</div><div>특히, 경로 내에 중복된 간선이 없는 경우 simple path라고 한다.</div><div><br></div><div><img width="533px" src="Files/image%20115.png"><br></div><div>digraph에서&nbsp;<span data-formula-width-em="3.75" data-upnote-formula="v_0 = v_n" data-non-editable="true">v_0 = v_n</span>&nbsp;이고 경로에 간선이 최소 하나가 존재한다면, 해당 경로를&nbsp;<span class="shine-text-red">사이클</span>(cycle)이라 한다.</div><div>simple graph에서는&nbsp;<span data-formula-width-em="3.75" data-upnote-formula="v_0=v_n" data-non-editable="true">v_0=v_n</span>이고 0&lt;n 인 경우, 해당 경로를 사이클이라 한다.</div><div><br></div><div><br></div><h2>트리</h2><div>모든 정점의 쌍이 경로로 연결된 simple graph를 연결 그래프(Connected Graph)라고 한다.</div><div>특히, 사이클이 존재하지 않는 연결 그래프를&nbsp;<span class="shine-text-red">트리</span>라고 한다.</div><div><br></div><div>트리의 정점 중 하나를&nbsp;<span class="shine-text-red">루트</span>로 지정하면, 그 트리를 루트 있는 트리라고 한다.</div><div>루트가 정해짐으로써 트리의 정점 간에 부모와 자식, 조상과 자손 관계가 성립하며, 루트로부터의 경로 길이를 통해 정점의 깊이가 정해진다.</div><div><br></div><div><br></div><h2>Multigraph</h2><div>multigraph는 한 정점 쌍에 대해 간선이 두 개 이상 존재할 수 있는 그래프이다.</div><div>multigraph에서는 간선 이름에 대해 정점의 무순서쌍을 대응시키는 함수로 간선을 정의한다.</div><div><blockquote>e1 →&nbsp;<span class="shine-text-red">{1, 2}</span>, e2 →<span class="shine-text-red">&nbsp;{1, 2}</span>, e3 → {2, 3}, ...<br></blockquote><div><br></div></div><div>multigraphs에서 self loop 를 허용한 것을&nbsp;<span class="shine-text-red">Pseudograph</span>라고 한다.</div><div><br></div><div><br></div><h2>Bipartite Graph</h2><div><img width="439px" src="Files/image%20116.png"><br></div><div>simple graph의 정접 집합 V 를 다음 조건을 만족하도록 두 집합 V1, V2 로 나누는 것이 가능할 경우, 이를 Bipartite Graph라고 한다.</div><div><ul><li>조건 : V1, V2 각각의 집합 내부에서 서로 인접한 정점의 쌍이 존재하지 않는다.</li></ul><div><br></div></div><div>만약 bipartite graph에서 V1의 각 정점이 V2의 모든 정점과 인접하다면, 이를 complete bipartite graph라 한다.</div><div>|V1| = m, |V2| = n 인 complete bipartite graph를 K<sub>m, n</sub>으로 표기한다.</div><div>K<sub>2, 4</sub>를 그리면 다음과 같다.</div><div><img width="360px" src="Files/image%20117.png"><br></div><div><br></div><div><br></div><h2>Planar graph (평면 그래프)</h2><div>그래프를 평면에 그렸을 때, 어떤 간선도 서로 교차하지 않도록 그릴 수 있는 방법이 있다면, 해당 그래프를 평면 그래프라 한다.</div><div>예를 들어, complete graph K<sub>4</sub>는 아래와 같이 평면에 간선이 교차하지 않도록 그릴 수 있으므로, 평면 그래프이다.</div><div><img width="415px" src="Files/image%20118.png"><br></div><div><br></div><div>complete graph K<sub>5</sub>와 bipartite graph K<sub>3,3</sub>은 평면 그래프가 아님이 알려져 있다.</div><div><img width="535px" src="Files/image%20119.png"><br></div><div>쿠라토프스키와 와그너 정리에 따르면, 어떤 그래프가 평면 그래프가 아닐 필요충분조건은, 해당 그래프의 subgraph로 K<sub>5</sub>또는 K<sub>3,3</sub>이 존재하는 것이다.</div><br><div><br></div><div><h2>Subgraph (부분 그래프)</h2><div>그래프 G의 일부분이 그 자체로 그래프가 된다면, 이를 G의 subgraph라 한다.</div><div>구체적인 정의는 다음과 같다.</div><div><br></div><div><ul><li>그래프 G = (V, E) 에 대해</li><li>V’ 이 V의 부분 집합, E’이 E의 부분 집합이고</li><li>G’ = (V’, E’)이 그 자체로 그래프인 경우</li><ul><li>즉 E’의 간선들이 V’내의 정점 쌍으로 구성된 경우</li></ul><li>G’을 G의 subgraph라 한다.</li></ul></div></div><div><br></div><div><br></div><h2>Adjacency Matrix (인접 행렬)</h2><div>그래프는 인접 행렬을 통해 컴퓨터에서 표현할 수 있다.</div><div>그래프 G를 나타내는 인접 행렬 A는 다음과 같이 정의된다.</div><div><ol><li>그래프의 각 정점에 1, 2, ..., |V| 까지의 고유한 번호가 매겨져 있다고 가정한다.</li><li>행렬 크기는 |V| x |V| 이다.</li><li>i행 j열 원소는 E에 간선 (i, j)가 존재한다면 1이고, 존재하지 않는다면 0이다.</li></ol></div><div><br></div><div>다음 그림은 인접 행렬을 통해 digraph를 나타낸 예시이다.</div><div><img width="310px" src="Files/image%20120.png">&nbsp; &nbsp;&nbsp;<img width="239px" src="Files/image%20121.png"><br></div><div><br></div><div><br></div><h2>Graph Isomorphism</h2><div>서로 모양이 같은 그래프를 isomorphic 이라 한다.</div><div><br></div><div>구체적으로, 두 pseudograph G1 = (V1, E1), G2 = (V2, E2) 에 대해</div><div><ul><li>|V1| = |V2|</li></ul></div><div>이고,</div><div><ol><li>f: V1 → V2</li><li>f 는 일대일 대응 함수</li><li>V1의 임의의 노드 u, v에 대해, u와 v 사이의 간선 개수가 f(u)와 f(v)사이의 간선 개수와 같다.</li></ol><div>위 조건들을 만족하는 함수 f가 존재할 수 있다면, G1이 G2에 isomorphic하다고 한다.</div></div><div>또한 함수 f를 isomorphism이라 한다.</div><div><br></div><div>두 그래프가 Isomorphic이라면 다음이 성립한다.</div><div><ol><li>정점 개수가 서로 같고, 간선 개수가 서로 같다.</li><li>대응하는 정점의 degree가 같다.</li><li>존재하는 subgraph가 서로 같다.</li><li>G1의 임의의 정점 a, b 간의 경로들의 길이가 G2의 정점 f(a), f(b)간의 경로들의 길이와 같다.</li></ol></div><div>이러한 특성이 두 그래프가 isomorphic임을 보장하진 않지만, 이 특성 중 만족하지 않는 게 하나라도 있다면 두 그래프가 isomorphic이 아님이 보장된다.</div><div><br></div><div><br></div><h2>Graph Connectivity</h2><div>그래프의 정점 u에서 v를 연결하는 경로가 존재한다면, u와 v가 Connected(연결) 되었다고 한다.</div><div>경로의 길이가 0인 경우, 즉 u = v인 경우도 connected라 한다.</div><div>모든 정점의 쌍에 대해 경로가 존재하는 그래프를 connected graph라 한다.</div><div><br></div><div><br></div><h2>Connected Component</h2><div>simple graph G = (V, E)에 대해, 다음 조건을 만족하는 V의 부분 집합 V’을 G의 Connected Component라 한다.</div><div><ol><li>V’의 모든 정점들은 서로 연결되어 있다.</li><li>V’의 각 정점에 대해, 해당 정점과 연결되어 있는 모든 정점은 V’에 포함되어야 한다. (즉, V’이 크기가 최대여야 한다. maximal)</li></ol><div><br></div></div><div><img width="372px" src="Files/image%20122.png"><br></div><div>위 그래프에는 세 개의 Connected Component가 존재한다.</div></div></body>