<head>
    <title></title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./styles.css">
</head>

<body class="light-theme blue_sky" style="padding: 20px;">
    <div class="shine-editor">
        <h1>2024-04-03-07. Arrays, for Search, Insert, Delete</h1>
        <div><br></div>
        <div>Search, Insert, Delete는 자료구조의 가장 중요한 연산이다.</div>
        <div>배열의 종류에 따라 이러한 연산을 어떻게 수행하는지 알아보자.</div>
        <div><br></div>
        <div><br></div>
        <h2>배열에 요소를 어떻게 저장할 것인가?</h2>
        <div>
            <ul>
                <li>Packed vs Unpacked</li>
                <ul>
                    <li>배열이 항상 가득 찬 것은 아니다. 사용하지 않는 자리가 있을 수도 있다.</li>
                    <li>빈 자리를 한 쪽으로 모을 것인가(Packed), 모으지 않을 것인가?(Unpacked)</li>
                </ul>
                <li>Sorted vs Unsorted</li>
                <ul>
                    <li>Item들이 정렬된 상태를 유지할 것인가?</li>
                    <li>Item(요소) : 자료구조에 저장되는 대상</li>
                </ul>
            </ul>
        </div>
        <div><br></div>
        <div><br></div>
        <h2>Packed, Unsorted</h2>
        <div><img width="696px" src="Files/image%202.png"><br></div>
        <div>Packed 배열의 경우, 유효하지 않은 값들을 뒤에 몰아놓고, 유효한 값의 갯수를 count라는 변수에 따로 저장해 둔다.</div>
        <div>위 사진에서 count는 5이다. 이때, index가 5이상인 요소에는 아무 값이나 저장해도 된다.</div>
        <div><br></div>
        <div>
            <ul>
                <li>Search : O(n) (Linear Search만 가능)</li>
                <li>Insert : O(1)</li>
                <ul>
                    <li>만약 index 2에 9를 저장한다면, 원래 있던 7은 index 5로 옮기기만 하면 된다. (sorting을 고려할 필요 없으므로)</li>
                    <li>count 변수를 1 증가시켜야 한다.</li>
                </ul>
                <li>Delete : O(1)</li>
                <ul>
                    <li>index 2의 값을 삭제하려면, index 4에 있던 값을 index 2에 쓰고 count변수를 1 감소시킨다.</li>
                </ul>
                <li>보통 Insert와 Delete를 하기 전에 Search를 먼저 한다. (ex insert시에 중복값을 허용 안하는 경우) 이때 Insert와 Delete에 걸리는 시간은 총
                    O(n)이 된다.</li>
            </ul>
            <div><br></div>
        </div>
        <div><br></div>
        <h2>Packed, Sorted</h2>
        <div><img width="677px" src="Files/image%203.png"><br></div>
        <div>
            <ul>
                <li>Search : O(logn) (Binary Search 사용 가능)</li>
                <li>Insert : O(n)</li>
                <li>Delete : O(n)</li>
            </ul>
            <div><br></div>
        </div>
        <div>Insert, Delete 시에 sorting을 유지하기 위해 뒤의 모든 값을 옮겨야 한다.</div>
        <div><br></div>
        <div><br></div>
        <h2>Unpacked, Unsorted</h2>
        <div><img width="698px" src="Files/image%204.png"><br></div>
        <div>빈 자리들이 흩어져 있으므로, count변수 하나로 사용되지 않는 Item을 파악할 수 없다. Item별로 사용 중인지 아닌지 표시하는 배열이 추가로 필요하다. 이 배열을 Mark라 하자.
        </div>
        <div><br></div>
        <div>
            <ul>
                <li>Search : O(n)</li>
                <li>Insert : 빈 자리가 어디 있는지 찾아야 하므로 O(n)이 걸림.</li>
                <ul>
                    <li>만약 index 1에 삽입한다면 원래 index 1에 있던 값은 다른 빈 자리에 옮겨야 함.</li>
                    <li>빈 자리를 index 0부터 linear search로 찾으면, 맨 마지막 자리만 빈 경우 Θ(n)시간이 걸림</li>
                </ul>
                <li>Delete : O(1)</li>
                <ul>
                    <li>Packed, Unsorted와 비교하면, 값을 옮길 필요 없이 Mark배열만 수정하면 되므로 좀 더 빠르다.</li>
                </ul>
            </ul>
        </div>
        <div><br></div>
        <div>
            <ul>
                <li>O(1)시간에 Insert하는 방법</li>
            </ul>
            <div><img src="Files/SmartSelect_20240324_204348_Samsung%20Notes.jpg" width="681px"><br>빈 자리의 index를 head라는
                변수에 따로 저장해 둔다. 빈 자리에는 아무 값이나 넣지 말고 다른 빈칸의 index를 넣는다.</div>
        </div>
        <div>
            <ul>
                <li>Insert를 할 때</li>
                <ul>
                    <li>head에 적힌 index로 접근한다. head에 5가 적혀 있고 index 5의 값이 7이라면, head의 값을 7로 고치고 index 5에 insert를 한다.</li>
                </ul>
                <li>Delete를 할 때</li>
                <ul>
                    <li>delete한 자리에 head의 값을 저장하고, head의 값은 delete한 자리의 index로 수정한다.</li>
                </ul>
            </ul>
        </div>
        <div><br></div>
        <div>배열 원소로 포인터를 저장하는 것과 비슷한 원리이다.</div>
        <div>가리키는 위치가 더이상 없다는 것은 -1로 표시하면 된다.</div>
        <div><br></div>
        <div><br></div>
        <h2>Unpacked, Sorted</h2>
        <div><img src="Files/image%205.png" width="609px"><br></div>
        <div>
            <ul>
                <li>Search : 빈 칸이 섞여 있는 상황에서 어떻게 Binary Search를 쓸 것인가?</li>
                <ul>
                    <li>중간에 사용했다가 지워진 값이 있을 순 있지만, 한 번도 사용하지 않은 값들은 뒤에 몰아 넣는다.</li>
                    <li>값이 지워져도 그 값을 수정하지는 않는다. 지워진 값들은 Binary Search에 사용 가능.</li>
                    <li>이 방법을 사용하면 O(logn)이 걸린다. 단, 지워진 값도 포함해서 Search를 해야 하므로 packed, sorted보다 느리다.</li>
                </ul>
                <li>Insert</li>
                <ul>
                    <li>Insert해야 할 위치 옆에 빈 자리가 있다면 빈 자리에 Insert하면 됨.</li>
                    <li>빈 자리가 없다면 빈 자리를 채울 때까지 뒤의 값들을 밀어냄.</li>
                    <li>O(n)이 걸린다.</li>
                </ul>
                <li>Delete</li>
                <ul>
                    <li>O(1)이 걸린다.</li>
                    <li>지울 때 값을 수정하지 않아야 Binary Search 가능. Mark배열만 수정하자.</li>
                </ul>
            </ul>
        </div><br>
    </div>
</body>