<head><title></title><meta charset="utf-8"><link rel="stylesheet" href="./styles.css"></head><body class="light-theme blue_sky" style="padding: 20px;"><div class="shine-editor"><h1>2024-04-03-08. String Matching</h1><div><br></div><h2>문자열의 접미부와 접두부</h2><div>문자열 x에 대해, 접두부와 접미부를 다음과 같이 정의한다.</div><div><ul><li>x의 접두부 : 문자열 x의 앞에 오는 부분 문자열</li><ul><li>문자열 x의 크기가 k인 접두부를 x<sub>k</sub>으로 표기한다. 즉, x<sub>k</sub>&nbsp; = x[1..k] 이다.</li><li>x = “banana” 일 때, x<sub>1</sub>=”b”, x<sub>2</sub>=”ba”, x<sub>3</sub>=”ban”, ... 이다.</li></ul><li>x의 접미부 : 문자열 x의 뒤에 오는 부분 문자열</li><ul><li>“e”, “le”, “ple” 등은 문자열 x = “apple” 의 접미부이다.</li></ul></ul><div><br></div><div><ul><li>배열 A에 대해, A[a..b] 는 인덱스 a부터 b까지의 원소를 순서대로 나열한 A의 부분 배열을 의미한다. 문자열도 배열의 일종이다.</li></ul><br></div></div><div><br></div><h2>String Matching 문제 정의</h2><div><ul><li>텍스트 : 길이가 n인 문자열 T</li><li>패턴 : 길이가 m인 문자열 P. 단, m&lt;=n<br></li><li>텍스트 T와 패턴 P를 구성하는 알파벳들의 집합을 ∑로 표기한다.</li><ul><li>예를 들어, T = “acaabc” 이고 P = “aab” 이면&nbsp;∑ = { a, b, c } 이다.</li></ul></ul><div><br></div><div>String Matching은&nbsp;<span class="shine-text-red">텍스트에서 패턴이 나타나는 위치</span>를 모두 찾는 문제이다.</div></div><div><ul><li>ex) 텍스트 abababc<u>abcabcd</u>abccbaabd<u>abcabcd</u>abcd 에서 패턴 abcabcd를 찾는 문제</li></ul><div><br></div></div><div>좀 더 정확히 정의하면,</div><div>m &lt;= i &lt;= n-1 이고 T[(i-m+1)..i] = P 를 만족하는 s값을 찾는 문제, 즉<span class="shine-text-red">&nbsp;T</span><sub><span class="shine-text-red">i</span></sub><span class="shine-text-red">의 접미부가 P인 i값</span>을 찾는 문제이다.</div><div><img src="Files/image%206.png" width="699px"><br></div><div><br></div><div><h2>String Matching의 응용</h2><div><ul><li>Word Processor의 검색</li><li>웹 검색 엔진</li><li>바이러스 검사 프로그램 : 바이러스와 유사한 바이트열을 string matching으로 찾는다.</li><li>생물학 : 특정 염기 서열을 찾는 데 사용된다.</li></ul></div></div><div><br></div><div><br></div><h2>String Matching 알고리즘의 출력값과 접미부 함수</h2><div>String Matching 알고리즘의 출력값을 생성하는 데&nbsp;<span class="shine-text-red">접미부 함수</span>가 사용된다.</div><div>접미부 함수<span class="shine-text-red">&nbsp;σ</span>는 정의역이 ∑* (∑의 원소로 구성할 수 있는 모든 문자열의 집합) 이고 공역이 {0, 1, ..., m} 인 함수로,&nbsp;σ(x)는&nbsp;<span class="shine-text-red">문자열 x의 접미부이면서 패턴 P의 가장 긴 접두부인 문자열의 길이</span>를 나타낸다.</div><div><div><br></div><div>예를 들어, P = “ab” 일 때,&nbsp;σ(”ccaca”) = 1,&nbsp;σ(”ccab”) = 2 이다.</div></div><div><img width="515px" src="Files/image%207.png"></div><div><br></div><div><span class="shine-text-red">S</span><span class="shine-text-red">tring Matching 알고리즘의 출력값은 접미부 함숫값의 배열</span>&nbsp;output = [ σ(T<sub>1</sub>),&nbsp;σ(T<sub>2</sub>),&nbsp;σ(T<sub>3</sub>), ...,&nbsp;σ(T<sub>n</sub>) ] 이다.</div><div>예를 들어, T = “abababacaba”, P = “ababaca” 이면, output = [ 1, 2, 3, 4, 5, 4, 5, 6,&nbsp;<span class="shine-text-red">7</span>,&nbsp;<span class="shine-text-red">2</span>, 3 ] 이다.</div><div><img src="Files/image%208.png" width="383px"><br></div><div><br></div><div><img src="Files/image%209.png" width="554px"><br></div><div>output 배열에서 값이 m인 원소의 인덱스를 통해 텍스트에서 패턴이 나타나는 위치를 알 수 있다.</div><div>위 예시에서 output[9] 에 m=7이 저장되어 있으므로, T<sub>9</sub>의 접미부에 P가 나타난다.</div><div><br></div><div><br></div><h2>Naive String Matching 알고리즘</h2><div><pre spellcheck="false" data-code-language="cpp">int[] naivematch(char T[], int n, char P[], int m) {<br>    int output[n];<br>    for(int k = 0; k &lt;= n-m; k++) {<br>        for(int j=1; j&lt;=m; j++) {<br>            if(T[k+j] == P[j])<br>                output[k+j] = max(output[k+j], j+1);<br>                // output[s+j]에 더 큰 값이 이미 저장되어 있을 수 있으므로 max 함수 사용<br>            else<br>                break;<br>        }<br>    }<br>    return output;<br>}</pre></div><div><div><br></div><div>naive string matching 알고리즘은 T[k+1..k+m]과 P[1..m] 을 비교한다. (단, k = 0, 1, 2, ..., n-m)</div><div><br></div><ul><li><img src="Files/image%2010.png" width="471px"></li><li><img src="Files/image%2011.png" width="472px"></li></ul><ul><li>안본 데부터 시작하면 못 찾는 경우가 생긴다.</li><ul><li><img src="Files/image%2012.png" width="450px"><br></li></ul><li>전체 문자열의 길이가 n, 찾으려는 문자열의 길이가 m일 때, 시간복잡도는 O(m(n-m))이다.</li></ul><div><br></div></div><h2><br></h2><h2>유한 오토마타(Finite Automaton)</h2><div>string matching 알고리즘의 성능을 개선하기 위해 유한 오토마타를 사용할 수 있다.</div><div>유한 오토마타 M은 다음과 같은 5-튜플 (Q, q<sub>0</sub>, A, ∑, δ)로 구성된다.</div><div><ul><li>Q : 유한한 개수의 상태(state)의 집합</li><li>q<sub>0</sub>&nbsp;∈ Q : 시작 상태</li><li>A ⊆ Q : “받아들이는” 상태의 집합</li><li>&nbsp;∑ : 입력 알파벳의 집합</li><li>δ : Q x&nbsp;∑ 에서 Q로 매핑되는 함수. M의 전이 함수라고 불린다.<br></li></ul><div><br></div></div><div>오토마타는 상태 q<sub>0</sub>에서 시작해 입력 문자열에서 한 번에 한 문자를 읽는다. 오토마타의 상태가 q이고 입력 문자 a를 읽으면 상태 q는 상태&nbsp;δ(q, a)로 바뀐다. 현재의 상태 q가 A에 속하면 오토마타가 현재까지 읽은 문자열을 받아들인다고 한다. 그렇지 않으면 거절한다고 한다.</div><div><br></div><div>예를 들어, 상태 집합이 Q = {0, 1} 이고, 시작 상태는 q<sub>0</sub>&nbsp;= 0, 받아들이는 상태는 A = {1}, 입력 알파벳은 ∑ = {a, b}일 때, 다음과 같이 전이 함수&nbsp;δ를 정의할 수 있다.</div><div><img src="Files/image%2013.png" width="183px"><br></div><div>&nbsp;δ(0, a) = 1,&nbsp;&nbsp;δ(0, b) = 0,&nbsp;&nbsp;δ(1, a) = 0,&nbsp;&nbsp;δ(1, b) = 0</div><div><br></div><div>이때, 유한 오토마타 M은 다음 그림과 같이 나타낼 수 있다.</div><div><img src="Files/image%2014.png" width="280px"><br></div><div>예를 들어, 문자열 “abaaa”가 입력되면 오토마타의 상태는 순서대로 0, 1, 0, 1, 0, 1 으로 변한다. 해당 문자열을 전부 읽었을 때, 오토마타의 상태는 A에 속하는 1이므로, 오토마타는 입력 “abaaa”를 받아들인다.</div><div><img src="Files/image%2015.png" width="765px"><br></div><div>반면, abbaa가 입력되었을 때 오토마타의 상태는 순서대로 0, 1, 0, 0, 1, 0으로 변하므로, 오토마타는 입력 ”abbaa”를 거절한다.</div><div><br></div><div>오토마타의 최종 상태 함수&nbsp;<span class="shine-text-red">Φ(w)</span>는&nbsp;<span class="shine-text-red">문자열 w를 전부 읽었을 때 오토마타의 최종적인 상태</span>로 정의된다.</div><div>최종 상태 함수는 다음과 같이 순환적으로 정의 가능하다.</div><div><ul><li>Φ(””) = q<sub>0</sub>&nbsp; (””는 빈 문자열을 의미)</li><li>Φ(wa) = δ(Φ(w), a) (단, w는 ∑의 원소로 구성된 문자열이며 a는&nbsp;∑내의 문자이다)</li><ul><li>두 문자열 x, y에 대해,&nbsp;<span class="shine-text-red">x뒤에 y를 연결한 문자열은 xy로 표기</span>한다. 위에서 wa는 w뒤에 문자 a를 연결한 문자열이다.</li></ul></ul></div><div>ex)&nbsp;Φ(”abbaa”) = 1,&nbsp;Φ(”abaaa”) = 0</div><div><br></div><div>오토마타가 문자열 w를 받아들일 필요충분조건은&nbsp;Φ(w)∈A 이다.</div><div><br></div><div><br></div><h2>DFA (Deterministic Finite Automaton)를 이용한 String Matching</h2><div>오토마타가 텍스트 T에서 i개의 문자를 읽었을 때 상태가 σ(T<sub>i</sub>) 라면, 즉<span class="shine-text-red">&nbsp;Φ(T</span><sub><span class="shine-text-red">i</span></sub><span class="shine-text-red">) = σ(T</span><sub><span class="shine-text-red">i</span></sub><span class="shine-text-red">)</span>라면, 해당 오토마타를 String Matching에 사용할 수 있을 것이다. 오토마타의 상태를 output 배열에 저장하면 된다.</div><div>이러한 오토마타를 스트링 매칭 오토마타라고 한다.</div><div><br></div><div>예를 들어, ∑ = {a, b, c} 이고 P = “ababaca”, T = “abababacaba” 일 때, 스트링 매칭 오토마타의 최종 상태 함수는 다음과 같다.</div><div><img src="Files/image%2016.png" width="627px"><br></div><div><br></div><div>아래 get_transition_fuction이 패턴 P에 대한 스트링 매칭 오토마타의 전이 함수를 리턴한다고 하자. 그렇다면 리턴된 오토마타를 이용해 다음과 같이 String Matching을 수행할 수 있다.</div><div><pre data-code-language="cpp" spellcheck="false">// O(|∑|m)<br>int[][] get_transition_fuction(char P[], int m, char[] ∑) {...}<br><br>// O(n)<br>int DFAmatch(char T[], int n, char P[], int m, char[] ∑) {<br>    int[][] table = get_transition_fuction(P, m, ∑);  // table[q][a] = δ(q, a)<br>    int s = 0;  // 오토마타의 상태<br>    for(int i=1; i&lt;=n; i++) {<br>        output[i] = s = table[s][T[i]];  // δ(s, T[i])<br>    }<br>}</pre></div><div><div><br></div><div>위 알고리즘에서, 스트링 매칭 알고리즘의 전이 함수를 구하는 데&nbsp;O(|∑|m), 전이 함수로 스트링 매칭을 수행하는 데 O(n) 시간이 걸린다.</div><div><ul><li>|∑|는 ∑의 원소 개수를 의미한다.</li></ul><div><br></div></div><div>총 O(|∑|m+n) 시간이 걸린다.</div><div><br></div></div><div><br></div><h2>String Matching 오토마타의 구성</h2><div>오토마타가&nbsp;Φ(T<sub>i</sub>) = σ(T<sub>i</sub>) 를 만족하도록 하려면 오토마타의 전이 함수를 어떻게 정의해야 할까?</div><div><br></div><div>패턴 P에 대응하는 스트링 매칭 오토마타는 다음과 같이 정의한다.</div><div><ul><li>상태 집합 Q는 {0, 1, ..., m} 이다.</li><li>초기 상태 q<sub>0</sub>는 0이다.</li><li>받아들이는 상태는 m 뿐이다. 즉, A = {m} 이다.</li><li>임의의 상태 q와 문자 a에 대해, 전이 함수&nbsp;δ는 다음과 같다.</li><ul><li><span class="shine-text-red">δ(q, a) = σ(P</span><sub><span class="shine-text-red">q</span></sub><span class="shine-text-red">a)</span></li></ul></ul><div><br></div></div><div>위와 같은 전이 함수를 가지는 오토마타는 0이상 n이하의 모든 정수 i에 대해 Φ(T<sub>i</sub>) = σ(T<sub>i</sub>) 를 만족한다.&nbsp;</div><div>이를 증명하기 위해 먼저 다음 두 가지 보조 정리를 증명한다.</div><div><br></div><div><ol><li>임의의 문자열 x와 문자 a에 대해&nbsp;σ(xa) &lt;=&nbsp;σ(x) + 1 이다.</li></ol></div><div><ul><ul><li>증명 :</li><li><img src="Files/image%2017.png" width="593px"><br></li><li>σ(x) = k 라 하자.<br></li><li>σ(xa) = r &gt; k+1 라고 가정한다. 이때, P<sub>r</sub>는 xa의 접미부가 된다.</li><li>P<sub>r</sub>의 끝과 xa의 끝에서 a를 삭제하면, P<sub>r-1</sub>은 x의 접미부가 된다.</li><li>r-1 &gt; k 이므로, P<sub>r-1</sub>은 P<sub>k</sub>보다 긴 x의 접미부가 된다.</li><li>이는&nbsp;σ(x) = k라는 전제와 모순이다.</li><li>따라서 r &lt;= k + 1, 즉&nbsp;σ(xa) &lt;=&nbsp;σ(x) + 1 여야 한다.</li></ul></ul><div><br></div><div><ol start="2"><li>임의의 문자열 x와 문자 a에 대해 σ(x) = q 이면 σ(xa) = σ(P<sub>q</sub>a) 이다.</li></ol></div><ul><ul><li>증명 :</li><li><img src="Files/image%2018.png" width="561px"><br></li><li>σ의 정의에 의하면, P<sub>q</sub>는 x의 접미부이다.<br></li><li>P<sub>q</sub>a는 xa의 접미부이므로 σ(P<sub>q</sub>a) &lt;= σ(xa) 가 성립한다.&nbsp; ...ㄱ<br></li><li>σ(xa) = r 이라 하면 보조정리 1에 의해 r&lt;=q+1 이다.<br></li><li>P<sub>q</sub>a는 xa의 접미부이고, P<sub>r</sub>도 xa의 접미부이며, |P<sub>r</sub>|&lt;=|P<sub>q</sub>a| 이므로, P<sub>r</sub>은&nbsp;P<sub>q</sub>a의 접미부이다.</li><li>따라서 r &lt;= σ(P<sub>q</sub>a), 즉&nbsp;σ(xa) &lt;=&nbsp;σ(P<sub>q</sub>a)이다.&nbsp; ...ㄴ</li></ul><ul><li>ㄱ, ㄴ을 종합하면&nbsp;σ(xa) &lt;=&nbsp;σ(P<sub>q</sub>a) &lt;= σ(xa), 즉&nbsp;σ(xa) =&nbsp;σ(P<sub>q</sub>a) 가 성립한다.</li></ul></ul><div><br></div></div><div>위 두 가지 보조 정리를 바탕으로, 전이 함수가&nbsp;δ(q, a) = σ(P<sub>q</sub>a)인 오토마타는&nbsp;0이상 n이하의 모든 정수 i에 대해 Φ(T<sub>i</sub>) = σ(T<sub>i</sub>) 를 만족함을 증명해 보자.</div><div><ul><li>Base : i = 0일 때,&nbsp;Φ(T<sub>0</sub>) = q<sub>0</sub>&nbsp;= 0&nbsp;=&nbsp;σ(T<sub>0</sub>) 로 성립한다.</li><li>Step : 어떤 정수 i에 대해 Φ(T<sub>i</sub>) = σ(T<sub>i</sub>)라 하면</li><ul><li>Φ(T<sub>i+1</sub>) =&nbsp;Φ(T<sub>i</sub>T[i+1]) =&nbsp;δ(Φ(T<sub>i</sub>), T[i+1])&nbsp; &nbsp; &nbsp; &nbsp;(→&nbsp;Φ의 정의에 의해)&nbsp;<br></li><li>Φ(T<sub>i</sub>) =&nbsp;σ(T<sub>i</sub>) = q 라 하면, δ(Φ(T<sub>i</sub>), T[i+1]) =&nbsp;δ(q, T[i+1]) =&nbsp;σ(P<sub>q</sub>T[i+1])&nbsp; &nbsp; (→&nbsp;δ의 정의에 의해)<br></li><li>보조정리 2에 의해,&nbsp;σ(P<sub>q</sub>T[i+1]) =&nbsp;σ(T<sub>i</sub>T[i+1]) 이 성립한다.</li><li>σ(T<sub>i</sub>T[i+1]) =&nbsp;σ(T<sub>i+1</sub>)이므로,&nbsp;Φ(T<sub>i+1</sub>) =&nbsp;σ(T<sub>i+1</sub>) 이다.</li></ul></ul></div><div><br></div><div>전이 함수를 리턴하는 알고리즘의 구체적인 구현은 생략한다.</div><div><br></div><div>∑ = {a, b, c} 이고 P = “ababaca” 일 때, 스트링 매칭 오토마타의 전이 함수는 다음과 같다.</div><div><img src="Files/image%2019.png" width="167px"></div><br></div></body>