<head><title></title><meta charset="utf-8"><link rel="stylesheet" href="./styles.css"></head><body class="light-theme blue_sky" style="padding: 20px;"><div class="shine-editor"><h1>2024-04-19-13. Binary Search Tree</h1><h2>Binary Search Tree(이진 탐색 트리, BST)의 정의</h2><div>배열은 삽입이나 삭제가 오래 걸리고, 연결 리스트는 이진 탐색을 할 수 없어 검색이 오래 걸린다.</div><div>Binary Search Tree는 삽입, 삭제, 검색 속도가 모두 빠르다.</div><div><br></div><div>BST는 구체적으로 아래와 같이 구성된다.</div><div><ul><li>각 노드는 key를 갖는다. key에 데이터가 저장된다.</li><li>각 노드는 다른 노드에 대한 포인터 L, R을 갖는다.</li><ul><li>L은 왼쪽 자식 노드, R은 오른쪽 자식 노드를 가리키는 포인터이다.</li><li>자식 노드가 없다면 포인터에 NULL이 저장된다.</li></ul><li>트리의 최상위 노드는 루트라고 부른다.</li></ul><div><br></div><div>이진 탐색 트리에서 키들은 다음 ‘이진 탐색 트리 특성’을 만족하도록 저장된다.</div><div><img src="Files/image%2045.png" width="378px"><br></div><div><ul><li>x를 이진 검색 트리의 한 노드라고 하자.</li><li>y가 왼쪽 서브 트리의 한 노드라면, y의 key값은 x의 key값보다 작다.</li><li>z가 오른쪽 서브 트리의 한 노드라면, z의 key값은 x의 key값보다 크다.</li></ul></div><div><br></div></div><div><br></div><h2>Search 알고리즘</h2><div><div><pre spellcheck="false" data-code-language="cpp">// root는 루트 노드의 주소<br>Node* Search(int X, Node *N = root) {<br>    if(N == NULL || X == N-&gt;key) {<br>        return N;<br>    if(X &lt; N-&gt;key) return Search(X, N-&gt;left)<br>    else return Search(X, N-&gt;right);<br>}</pre></div><div>루트 노드에서 시작하여 재귀 호출을 통해 특정 키 값을 갖는 노드를 찾는 알고리즘이다.</div></div><div>현재 노드의 키 값이 인수로 주어진 키 값과 같으면, 현재 노드의 주소를 리턴한다.</div><div>현재 노드의 키 값이 더 크면 왼쪽 자식 노드에 대해 재귀 호출하고, 더 작으면 오른쪽 자식 노드에 대해 재귀 호출한다.</div><div><br></div><div>다음으로, Search 알고리즘의 정확성을 증명해 보자. 다음 두 가지를 증명하면 된다.</div><div><ol><li>키값으로 X를 가지는 노드 A가 BST에 존재한다면, Search(X, root)는 A의 주소값을 리턴한다.</li><ul><li>이는 다음을 통해 증명된다 :</li><li>Search(X, N) 이 호출될 때, N을 루트로 하는 서브트리 내에 A가 존재함을 먼저 증명하자. (N은 임의의 노드)</li><ul><li>Base : Search(X, root)부터 시작한다. 트리 내에 A가 존재한다고 가정하였으므로, root를 루트 노드로 하는 서브트리, 즉 전체 트리 내에 A가 존재한다.</li><li>Step : Search(X, N)에서, N을 루트로 하는 서브트리 내에 A가 존재한다고 가정한다.</li><ul><li>N의 왼쪽 서브트리에 A가 존재한다면, 이진 탐색 트리의 특성에 의해 X &lt; N-&gt;key 가 참이 된다. 따라서 N의 왼쪽 자식 노드에 대해 재귀 호출되고, 다음 호출에서도 서브트리 내에 A가 존재하게 된다.</li><li>N의 오른쪽 서브트리에 A가 존재하는 경우에도, 마찬가지 이유로 다음 호출에도 가정이 참이 된다.</li><li>N==A라면, X == N-&gt;key가 참이 되고, A의 주소값이 리턴되어 알고리즘이 올바르게 작동을 마친다.</li></ul></ul><li>따라서 Search(X, N)이 수행될 때 무조건 N을 루트로 하는 서브트리 내에 A가 존재하게 되며, 서브트리의 크기는 재귀 호출될 때마다 계속 작아지므로, 결국 A가 리턴된다.</li></ul><li>키값으로 X를 가지는 노드가 BST에 없다면, Search(X, root)는 NULL을 리턴한다.</li><ul><li>노드의 키 값이 인수로 주어진 값과 같을 때만 주소값이 리턴된다. 그런 노드가 존재하지 않고, 자식 노드를 타고 내려가다 보면 N에 NULL이 들어가게 되므로, 결국 NULL이 리턴된다.</li></ul></ol></div><div><br></div><div><br></div><h2>Search 수행 시간</h2><div>루트 노드에서 트리의 가장 아래쪽에 있는 노드까지의 경로 길이를 트리의 높이라고 한다.</div><div><img src="Files/image%2046.png" width="390px"><br></div><div>(위 그림의 트리 높이가 6이라고 정의하는 경우도 있다)</div><div><br></div><div>트리의 노드 개수가 N일 때, Search의 수행 시간은 다음과 같다.</div><div><ul><li>높이가 H인 특정한 Tree를 가정했을 때</li><ul><li>최악의 경우 O(H)가 걸린다.</li></ul><li>모든 생성 가능한 Tree에 대해서</li><ul><li><img src="Files/image%2047.png" width="108px"><br></li><li>위와 같이 노드가 수직 방향으로 일렬로 배열된 트리가 최악의 경우이다.</li><li>이 경우 H=N-1이므로, O(N)이 걸린다.</li></ul></ul></div><div><br></div><div>트리의 높이는 평균적으로 logN이다. 따라서 Search의 수행 시간도 평균 O(logN)이다.</div><div><br></div><div><br></div><h2>Insert 알고리즘</h2><div><pre spellcheck="false" data-code-language="cpp">void Insert(int X, Node* N = root, Node **RP = &amp;root)<br>{<br>    Node *new_node;<br>    if(N == NULL) {<br>        new_node = new Node;<br>        new_node-&gt;key = X; new_node-&gt;left = new_node-&gt;right = NULL; *RP = new_node;<br>    }<br>    else {<br>        if(N-&gt;key &lt; X) return Insert(X, N-&gt;right, &amp;(N-&gt;right));<br>        else if(N-&gt;key &gt; X) return Insert(X, N-&gt;left, &amp;(N-&gt;left));<br>        else return;  // 중복된 키값이 있으면 Insert 취소<br>    }<br>}</pre></div><div><div><br></div><div>Insert알고리즘은 Search와 같은 방식으로 트리를 따라 내려간다. RP에는 N의 부모 노드에서 N을 가리키는 포인터의 주소가 저장된다.</div><div><br></div><div>Insert 알고리즘이 Search 알고리즘과 매우 유사하므로, Insert알고리즘의 정확성을 증명하는 데 Search 알고리즘의 정확성을 사용할 수 있다.</div><div><ul><li>Insert를 하려는 트리에 key값이 X인 노드 A가 존재한다고 가정하자.</li><ul><li>Insert와 Search알고리즘의 유사성에 의해, Search알고리즘에서와 같은 경로를 따라 노드 A까지 도달하게 된다.</li><li>노드 A에 도달하면 return; 이 실행되어 Insert가 취소되고, 알고리즘이 정확하게 작동을 마친다.</li></ul><li>이제 위의 트리에서 노드 A만 삭제된 트리를 가정해 보자. (또한 A의 자식 노드는 없었다고 가정)</li><ul><li>노드 P가 노드 A의 부모 노드였다면, P까지의 재귀 호출은 A가 존재하는 경우와 달라지지 않는다.</li><li>P 다음의 재귀 호출에 전달되는 인수는 A가 있었던 경우의 재귀 호출에서 N만 NULL로 바뀐 것이다. RP에는 A가 저장되야 할 위치가 전달되게 된다.</li><li>P다음의 재귀 실행에서는 RP에 A를 생성해 저장하므로, Insert가 정확하게 동작한다.</li></ul></ul></div><div><br></div></div><div><br></div><h2>Delete 알고리즘</h2><div><ul><li>먼저 Search()를 수행한다.</li><li>만약 Search()가 실패하면, Delete를 하지 않고 함수를 종료한다.</li><li>만약 Search()에 성공해 지울 노드 N을 찾았다면, 다음 세 가지 case를 고려해야 한다.</li><ol><li>지울 노드의 자식이 없는 경우</li><ul><li>N의 부모 노드의 포인터에 NULL을 대입하고, N을 메모리에서 해제하여 삭제하면 된다.</li></ul><li>지울 노드의 자식이 1개인 경우</li><ul><li>N의 부모 노드의 포인터에 N의 자식 노드를 대입하고, N을 메모리에서 삭제한다.</li></ul><li>지울 노드의 자식이 2개인 경우</li></ol><ul><ul><li>Tree의 모든 노드를 sorting된 상태에서 일렬로 배열하면, 노드 N 바로 다음에 노드 x가 온다고 하자.</li></ul></ul></ul></div><div><ul><ul><ul><li>x는 N의 오른쪽 자식 노드에서 왼쪽으로만 최대한 타고 내려간 위치에 존재한다.</li><li><img src="Files/image%2048.png" width="344px"><br></li><li>노드 x의 키값을 N의 키값에 대입하고, x노드에 대해 Delete연산을 재귀 호출한다. x노드는 자식이 없거나 1개이므로 case 1, 2의 방법으로 지울 수 있다.</li><li><img src="Files/image%2049.png" width="265px"><br></li></ul></ul></ul></div><div><br></div><div><pre spellcheck="false" data-code-language="cpp">// parent는 N의 부모 노드를 가리킴<br>int Delete(Node *N, Node *parent)<br>{<br>    if(N-&gt;left == NULL &amp;&amp; N-&gt;right == NULL) {<br>        if(parent-&gt;left == N) parent-&gt;left = NULL;<br>        else parent-&gt;right = NULL;<br>        delete N;<br>    }else if(N-&gt;left == NULL || N-&gt;right == NULL) {<br>        if (parent-&gt;left == N) {<br>            if(N-&gt;left != NULL) parent-&gt;left = N-&gt;left;<br>            else parent-&gt;left = N-&gt;right;<br>        }<br>        else {<br>            if(N-&gt;left != NULL) parent-&gt;right = N-&gt;left;<br>            else parent-&gt;right = N-&gt;right;<br>        }<br>    }else {<br>        // 일렬로 배열했을 때 노드 N 바로 다음에 오는 노드를 next_N이라 하고<br>        // next_N의 부모 노드를 next_N_parent라 한다.<br>        Node* next_N = N-&gt;right;<br>        Node* next_N_parent = N;<br>        while(next_N-&gt;left != NULL) {<br>            next_N_parent = next_N;<br>            next_N = next_N-&gt;left;<br>        }<br>        N-&gt;key = next_N-&gt;key;<br>        Delete(next_N, next_N_parent);<br>    }<br>}</pre><div><br></div></div><div><br></div><div><br></div><h2>Delete 알고리즘 정확성</h2><div>위 알고리즘 수행 뒤 이진 탐색 트리 특성이 깨지지 않음을 증명해 보자.</div><div><br></div><div><ol><li>자식이 없는 노드를 지우는 경우</li><ul><li>어떤 노드가 삭제되었을 때, 임의의 노드 x의 왼쪽 서브트리에 x보다 키값이 큰 노드가 생기거나, x의 오른쪽 서브트리에 x보다 키값이 작은 노드가 생길 수는 없다.</li><li>자식이 없는 노드를 지울 때는 단순히 그 노드를 삭제하므로, 이진 탐색 트리 특성이 깨지지 않는다.</li></ul><li>자식이 한 개인 노드 N을 지우는 경우</li><ul><li>N의 부모 노드를 P, 자식 노드를 C라 하자.</li><li><img src="Files/image%2050.png" width="225px"><br></li><li>N이 P의 왼쪽 자식이라면, 이진 탐색 트리의 특성에 의해, N을 루트로 하는 서브트리의 모든 노드는 키값이 P보다 작다.</li><li>따라서 C를 루트로 하는 서브트리의 모든 노드는 키값이 P보다 작다.</li><li>또한 C를 루트로 하는 서브트리는 그 자체로 이진 탐색 트리 특성을 만족한다.</li><li>따라서 N을 지우고, 그 자리에 C를 루트로 하는 서브트리가 와도 이진 탐색 트리 특성이 유지된다.</li><li>N이 P의 오른쪽 자식인 경우도 마찬가지 원리로 이진 탐색 트리 특성이 유지됨을 증명할 수 있다.</li></ul><li>자식이 두 개인 노드 N을 지우는 경우</li><ul><li>N의 오른쪽 자식 노드에서 출발하여 왼쪽으로만 최대한 타고 내려갈 경우, 노드 x에 도달하게 된다고 하자.</li><li>x는 N보다 키값이 큰 노드들 중에서 가장 키값이 작은 노드이다.</li><ul><li>증명은 다음과 같다.</li><li>N외의 노드를 N의 왼쪽 서브트리의 노드, N의 오른쪽 서브트리의 노드, 그 외 N의 조상 노드와 그것의 자손 노드로 구분할 수 있다. 각각의 노드에 대해 N보다 키값이 작서나, x보다 크다는 것을 증명할 것이다.</li><li>case 1) N의 왼쪽 서브트리의 노드는 모두 N보다 키값이 작다.</li><li>case 2) N의 오른쪽 서브트리의 노드는 모두 N보다 키값이 크다.</li></ul><ul><li>여기서 x는 서브트리에서 가장 키값이 작다. 서브트리 내 임의의 노드의 오른쪽 자식 노드는 부모보다 키값이 크기 때문에 가장 작은 노드가 될 수 없고, x의 부모들도 모두 x보다 크기 때문이다.</li><li>case 3) N의 임의의 부모 노드 P에 대해, N이 P의 오른쪽 서브트리에 존재한다면 P의 키값은 N보다 작다. P의 왼쪽 서브트리의 노드도 전부 N보다 작다.</li><li><img src="Files/image%2051.png" width="316px"><br></li><li>N이 P의 왼쪽 서브트리에 존재한다면 P의 키값은 N보다 크다. 그런데 x도 P의 왼쪽 서브트리에 포함되므로 P의 키값은 x보다 크다. P의 오른쪽 서브트리의 노드도 x보다 키값이 크다.</li><li><img src="Files/image%2052.png" width="325px"><br></li></ul><li>따라서 (어차피 삭제될 노드 x를 고려하지 않으면) N의 키값을 x의 키값으로 고쳐도 이진 탐색 트리 특성이 유지된다.</li><li>x는 자식이 한 개 이하이므로, 재귀 호출을 통해 이진 탐색 트리 특성을 유지하도록 삭제가 이루어진다.</li></ul></ol></div><br></div></body>