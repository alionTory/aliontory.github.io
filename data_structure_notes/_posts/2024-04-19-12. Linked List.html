<head><title></title><meta charset="utf-8"><link rel="stylesheet" href="./styles.css"></head><body class="light-theme blue_sky" style="padding: 20px;"><div class="shine-editor"><h1>2024-04-19-12. Linked List</h1><h2>Linked List의 정의</h2><div><br></div><div><img src="Files/image%2043.png" width="594px"><br></div><div><ul><li>Node들과 head 하나로 구성된다.</li><li>Node는 저장 공간의 한 단위로, 데이터 저장 공간과 포인터로 구성된다.</li><li>Node의 포인터에는 다음 노드의 주소가 저장되어 있다.</li><li>head는 첫 번째 노드의 주소를 저장하는 포인터이다.</li><li>위 그림은 값 12, 99, 37을 순서대로 저장하는 Linked List를 그림으로 나타낸 것이다. 데이터로 12가 저장된 노드의 포인터는 99가 저장된 다음 노드의 주소를 저장하고 있다.</li><li>위 그림에서, head에는 12가 저장된 노드의 주소가 저장되어 있을 것이다.</li></ul><div><br></div></div><div><br></div><h2>Linked List 코드</h2><div>다음은 ‘정렬된’ Linked List와 그것의 생성, 검색, 삽입, 삭제, 소멸 함수들이다.</div><div><pre spellcheck="false" data-code-language="cpp">class Node {<br>    int data;<br>    Node *n;<br>};<br><br>class List {<br>    List();<br>    ~List();<br>    int Search();<br>    int Insert();<br>    int Delete();<br><br>    Node *head;<br>    /* 다음 p, l은 search에 사용할 포인터이다.<br>       검색에 성공할 경우, l에는 검색한 값을 가지는 노드의 주소가 저장되고, p에는 그 이전 노드의 주소기 저장된다.<br>       검색에 실패할 경우, p와 l이 가리키는 노드 사이에 검색값이 삽입되야 정렬된 상태를 유지하도록, p와 l값이 정해진다. */<br>    Node *p, *l;<br>};<br><br>List::List() {<br>    head = nullptr;<br>}<br><br>List::~List() {<br>    Node *current, *next;<br>    current = head;<br>    while(current != nullptr) {<br>        next = current-&gt;n;<br>        delete current;<br>        current = next;<br>    }<br>}<br><br>/* Search는 Linear Search 알고리즘을 이용한다.<br>   linked list는 중간 노드에 바로 접근할 수 없으므로, binary search를 빠르게 할 수 없다. */<br>int List::Search(int x) {<br>    p = nullptr;<br>    l = head;<br>    while(l != nullptr) {<br>        if(l-&gt;data == x) return 1;<br>        else if(l-&gt;data &gt; x) return 0;<br>        else {<br>            p = l; l = l-&gt;n;<br>        }<br>    }<br>    return 0;<br>}<br><br>int List::Insert(int x) {<br>    if(!Search(x)) {  // 중복값을 막기 위해 검색에 실패했을 때만 Insert<br>        Node* new_node = new Node;<br>        new_node-&gt;data = x;<br>        if(p == nullptr)<br>            head = new_node;<br>        else<br>            p-&gt;n = new_node;<br>        new_node-&gt;n = l;<br>        return 1;<br>    }<br>    return 0;<br>}<br>       <br>List::Delete(int x) {<br>    if(Search(x)) {<br>        if(p==nullptr)<br>            head = l-&gt;n;<br>        else<br>            p-&gt;n = l-&gt;n;<br>        delete l;<br>        return 1;<br>    }<br>    return 0;<br>}</pre><div><br></div></div><div>Search 결과에 nullptr이 들어간 경우를 다루기 위해 if문을 사용해야 했다. -∞와&nbsp;∞가 저장된 Node를 리스트 앞, 뒤에 저장하면,&nbsp;이런 경우를 따로 처리하지 않아도 된다.</div><div><br></div><div><br></div><h2>Linked List 성능</h2><div><ul><li>정렬된 리스트의 경우</li><ul><li>정렬되어 있어도 인덱스의 중간값에 바로 접근할 수 없으므로 binary search 불가.</li><li>Search : O(n)</li><li>Inseart : S + O(1)&nbsp; (S는 search 에 걸리는 시간)</li><li>Delete : S + O(1)</li></ul><li>정렬되지 않은 리스트의 경우</li><ul><li>Search : O(n)</li><li>Insert : O(1) (정렬을 유지할 필요가 없으므로, Search 없이 그냥 head에 노드를 추가하면 됨)</li><li>Delete : S + O(1)</li></ul></ul></div><div><br></div><div>Linked List는 binary search를 사용할 수 없어, Array보다 search 가 느리다.&nbsp;</div><div><br></div><div>stack, queue를 구현할 때 Array 대신 Linked List를 사용할 수도 있다.</div><br><div><br></div><div><h2>Skip List에 대한 아이디어</h2><div><img width="635px" src="Files/image%2044.png"><br></div><div>skip list는 linked list에서 binary search를 할 수 있도록, 중간 원소로 바로 갈 수 있는 포인터들을 추가한 것이다.</div><br></div></div></body>