<head><title></title><meta charset="utf-8"><link rel="stylesheet" href="./styles.css"></head><body class="light-theme blue_sky" style="padding: 20px;"><div class="shine-editor"><h1>2024-05-17-16. Red-Black Tree</h1><h2>Red-Black Tree</h2><div>2-3-4 트리에서는 노드마다 3개의 키를 담을 공간이 필요하다. 이때, 2-노드와 3-노드에는 자리가 2개, 1개가 비게 된다. 이로 인해 메모리가 낭비될 수 있다.</div><div><br></div><div>2-3-4트리를 Red-Black 트리로 표현하면 빈 자리가 생기는 것을 막을 수 있다.</div><div>Red-Black 트리의 각 노드는 키를 하나만 가지며, 간선의 색깔을 지정하는 라벨을 가진다.</div><div>간선에는 두 가지 색깔 중 하나가 지정될 수 있는데, 검은색 간선은 일반적인 BST의 간선이다.</div><div>또한 붉은색 간선이라는 특수한 간선이 있는데, 이를 통해 3-노드, 4-노드를 표현한다.</div><div><br></div><div>3-노드는 Red-Black 트리에서 다음과 같이 표현된다.</div><div><img width="723px" src="Files/image%2081.png"><br></div><div>2-3-4트리에서 하나의 노드 안에 있던 키값들은, Red-Black 트리에서 두 노드로 나뉘어저 붉은색 간선으로 연결된다.</div><div><br></div><div>4-노드는 다음과 같이 표현된다.</div><div><img width="664px" src="Files/image%2082.png"><br></div><div>마찬가지로 하나의 노드 안에 있던 키값들이 나뉘어져 붉은색 간선으로 연결된다.</div><div><br></div><div><img width="242px" src="Files/image%2083.png"><br></div><div>다만 4-노드를 위와 같이 세 개의 층으로 표현해선 안 된다.</div><div>즉, 아래로 내려가는 경로에서, 붉은색 간선이 연속적으로 등장해선 안 된다.</div><div><br></div><div>위와 같은 정의를 바탕으로, 레드-블랙 트리는 다음과 같은 특성을 가진다.</div><div><ul><li>2-3-4트리에서 모든 리프 노드의 깊이가 같으므로, Red-Black 트리의 루트에서 널 포인터까지 내려갈 때 거치는 검은 간선 개수도 항상 같다.</li><ul><li>여기서 루트부터 ‘리프 노드’까지 내려갈 때의 검은 간선 개수가 같다고만 하는 것은 불충분하다. 2-3-4트리와 달리 붉은 간선 하나와 널 포인터 하나를 갖는, 자식이 하나비어 있는 노드가 존재할 수 있기 때문이다.</li></ul><li>위에서 언급했듯이, 아래로 내려가는 경로에서 붉은 간선이 연속적으로 존재할 수 없다.</li><ul><li>따라서 루트에서 널 포인터까지 K개의 검은 간선이 등장했다면, 붉은 간선은 최대 K+1 개 등장할 수 있다.</li></ul></ul><div><br></div><div><br></div><h2>Red-Black Tree에서 4-노드의 분할</h2><div>2-3-4트리에서는 insert과정에서 4-노드를 만나면 두 개의 2-노드로 분할하였다.</div><div>red-black 트리에서는 (붉은 간선으로 표현된) 4-노드를 만나면 다음과 같이 처리한다.</div><div><img width="661px" src="Files/image%2084.png"><br></div><div>노드 b에 붉은 간선으로 연결된 두 자식 노드가 연결되어 있을 때, 두 붉은 간선을 검은색으로 바꾸고 b의 부모 노드로 이어지는 검은 간선을 붉은색으로 바꾸기만 하면 된다.</div><div><br></div><div>단, 여기서 b의 부모 노드가 x이고, x의 부모 노드가 y라고 할 때, x와 y를 잇는 간선이 붉은색이면 문제가 발생한다.</div><div><img width="713px" src="Files/image%2085.png"><br></div><div>위와 같이 연속된 붉은 간선이 생기게 된다. 이는 AVL트리와 마찬가지로 회전을 통해 해결할 수 있다.</div><div><img width="721px" src="Files/image%2086.png"><br></div><div><br></div><div>다음과 같이 연속된 붉은 간선의 방향이 서로 다르면 처리하기 좀 더 복잡하다.</div><div><img width="661px" src="Files/image%2087.png"><br></div><div>이때는 회전을 다음과 같이 두 번 해주면 된다.</div><div><img width="723px" src="Files/image%2088.png"><br></div><div><br></div><div>insert후에도 연속된 붉은 간선이 생길 수 있다. 이런 경우 위와 마찬가지로 회전을 통해 해결한다.</div><div><br></div></div><div><br></div><h2>2-3-4트리에 독립적인 Red-Black 트리 정의</h2><div>Red-Black 트리는 2-3-4트리와 독립적으로 다음과 같이 정의할 수 있다.</div><div><br></div><div>Red-Black 트리는 붉은 간선과 검은 간선으로 구성된 BST이다.</div><div>또한 다음 두 조건을 만족해야 한다.</div><div><ol><li>루트에서 널 포인터까지의 경로에서 검은 간선 개수는 항상 같아야 한다.</li><li>아래로 내려가는 경로에서 연속적인 붉은 간선은 없어야 한다.</li></ol></div><div><br></div><div>insert는 다음과 같이 진행된다.</div><div><ul><li>먼저 일반적인 BST방식으로 노드를 insert한다. 이때 새 노드를 잇는 데 red edge를 사용한다.</li><li>연속적인 붉은 간선이 생겼다면 rotate를 수행하여 고친다.</li><li>한 노드 밑에 두 개의 붉은 간선이 있는 경우, 두 붉은 간선을 검은색으로 바꾸고, 부모 노드와 이어진 간선을 붉은색으로 바꾼다. 이러한 연산은 위쪽으로 전파될 수 있다.</li><ul><li>2-3 트리와 같은 방식이다.</li></ul><li>다른 방법으로는 insert를 완료하기 전 내려오는 과정에서 두 붉은 간선을 검은색으로 바꾸고, 위쪽 간선을 붉은색으로 바꾸는 방법도 있다.</li><ul><li>2-3-4 트리와 같은 방식이다.</li></ul></ul></div><div><br></div><div><br></div><h2>AVL 트리와의 비교</h2><div>Red-Black 트리와 AVL트리는 다음과 같은 세 가지 지점에서 유사하다.</div><div><br></div><div><ol><li>red-black 트리에서 루트부터 널 포인터까지 제일 긴 경로의 길이가 h라면, 제일 짧은 경로의 길이는 약 h/2 이상이다.</li></ol></div><div><ul><ul><li>경로에서 거쳐 가는 검은색 간선의 수가 k개라면, 가능한 경로의 최소 길이와 최대 길이는 다음과 같기 때문이다.</li><ul><li>최소 길이 : 검은색 간선으로만 이루어진 경우, k</li><li>최대 길이 : 사이사이에 항상 붉은 간선이 껴 있는 경우, 2*k</li></ul></ul></ul><div><ol start="2"><li>왼쪽과 오른쪽 서브트리의 높이는 최대 2까지 차이가 날 수 있다.</li><li>회전 연산으로 균형을 유지한다.</li></ol></div></div></div></body>